{"componentChunkName":"component---src-templates-blog-post-js","path":"/universal-javascript-app/","webpackCompilationHash":"ed5f58330506794fbc3c","result":{"data":{"site":{"siteMetadata":{"title":"Jeremy Bernier","author":"@gatsbyjs"}},"markdownRemark":{"id":"aad1bdbb-e9d7-5734-952a-e696e147836c","excerpt":"In this post I will explain what this is, and the basic idea of how to make one. Feel free to check out my React Redux boilerplate to see a…","html":"<p>In this post I will explain what this is, and the basic idea of how to make one. Feel free to check out <a href=\"/react-redux-node-boilerplate\">my React Redux boilerplate</a> to see a working implementation of what I’m about to explain.</p>\n<p>First, let’s define what a universal Javascript Single-Page app with server-side rendering is.</p>\n<h3>Single-Page App</h3>\n<p>A single-page app (SPA) is basically a website without page refreshes.</p>\n<p>The main advantage is speed, but you can also do a hell of a lot more without page refreshes. For example, you can</p>\n<ul>\n<li>Have media playing across pages, such as music or video. Music players have to be SPAs because otherwise the music would stop every time you navigated to a new page (my first professional job working on an SPA was on a <a href=\"/iheart\">music player website</a>).</li>\n<li>Share state in memory across pages. I did this on <a href=\"/vroom\">an ecommerce site I built</a> to cache product data and avoid having to refetch data that’s already been obtained, saving bandwidth as well.</li>\n<li>Page animations</li>\n</ul>\n<p>Ultimately, SPAs are way faster and more powerful than normal websites. So why aren’t they the norm? Because they’ve historically been very complex to build. But now with libraries like React and React-Router, that is no longer the case.</p>\n<p>Now a really simplistic way to build a SPA is to just bundle all your Javascript code on the client, send an incomplete HTML file and offload all the rendering work to the client. In fact, the first front-end frameworks like Angular 1 did this. The problem is that 1. the website loads jankier and slower with a lot of shifting elements, meaning an inferior user experience 2. terrible for SEO because search engines can’t crawl your site.</p>\n<p>A better way is to initially render the site on the server (<strong>server-side rendering</strong>), and then for subsequent page navigations, you render on the client.</p>\n<p>Ok, so we know that to render our views on the client, we need to use Javascript because it’s the only language web browsers accept for client-side scripting (though with Web Assembly, maybe that’ll change in the future). So how do we render our views on the server?</p>\n<p>Before Node.js, you would’ve had to rewrite your client-side rendering logic in whatever language you were using on the backend (eg. Python). But thankfully with Node.js, you can reuse the same client-side Javascript code on the server.</p>\n<h3>Universal Javascript (a.k.a isomorphic Javascript)</h3>\n<p>This just means that your Javascript runs on both the client and the server (via Node.js). If your rendering logic is on both the client and server, then you can reuse the same code. This reduces the amount of code and leaves one source of truth, saving the developer the time and hassle of dealing with multiple codebases.</p>\n<h3>Building a SPA</h3>\n<p>Great, so now we know that we can use Node.js to build a blazing fast SPA with server-side rendering. How do we actually build one?</p>\n<p>First of all, there are frameworks like <a href=\"https://nextjs.org/\">Next.js</a> which do a lot of the work for you (and for static websites, <a href=\"https://www.gatsbyjs.org\">Gatsby</a>). But let’s say you want to build one yourself without being tied down to a framework.</p>\n<p><strong>1. Transferring state from server to client</strong></p>\n<p>It’s important that on the initial page load, the client receives not only the fully rendered HTML, but also the application state. You can send the state from server to client by simply defining it as a global variable on the <code class=\"language-text\">window</code> object in your server-side HTML template, and then reading this on the client (note: you should generally never use global variables on the <code class=\"language-text\">window</code> object, but this is one of those cases where it’s unavoidable).</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// ServerHtmlTemplate.js\n\n&lt;body&gt;\n  ...\n  &lt;script&gt;\n    window.__INITIAL_STATE__= ${JSON.stringify(initialState)}\n  &lt;/script&gt;\n&lt;/body&gt;</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// client.js\n\nconst initialState = window.__INITIAL_STATE__\nconst store = configureStore(initialState) // Create Redux store using this state</code></pre></div>\n<p>In this case, <code class=\"language-text\">window.__INITIAL_STATE__</code> is the global variable that stores all of your initial state data. If you’re using Redux (a popular React state management library), then you can then set your store to this initial state.</p>\n<p><strong>2. Asynchronous calls</strong></p>\n<p>Naturally you’re going to have pages where you make an API call to fetch all of the data necessary for the page. For example, a blog will have a page with a list of all of the blog posts. How do you cleanly do this in a SPA?</p>\n<p>The way I implemented this in my boilerplate was to have an optional static <code class=\"language-text\">fetchData()</code> function that can be specified on any React page component and returns a <code class=\"language-text\">Promise</code>. Within this function, any asynchronous API calls can be specified. Then in your server and client-side rendering logic, you can first check for the existence of this fetchData() function, and if it exists, you can call it first and defer rendering until it’s complete.</p>\n<p>However, if you are doing this, <code class=\"language-text\">it is extremely important to set a timeout</code> in case the API call takes forever or hangs indefinitely. Otherwise your user will be forced to sit their with a blank page until the call is finished or the connection times out. I handled this by setting a 1 second timeout (check the <code class=\"language-text\">serverRender.js</code> file of my boilerplate to see this implementation).</p>\n<p><strong>3. Code Splitting</strong></p>\n<p>Without code splitting, a large SPA would contain all of the code of the entire website, which could potentially be a very massive Javascript file. Thankfully with code splitting, we can avoid this and only send the code required for the current page. With webpack, this is pretty simple to implement. Bundles can be separated as follows:</p>\n<ul>\n<li><em>vendor.js</em> - This bundle will contain all of your NPM module dependencies. The idea is that it won’t change as frequently</li>\n<li><em>main.js</em> - This will contain all of your main application logic</li>\n<li><em>[specific-page].js</em> - This will contain the code for the specific page that the user is accessing.</li>\n</ul>\n<p>By splitting up your code, you can increase performance and save bandwidth by only loading the code that’s necessary, while caching the code that changes infrequently.</p>\n<h3>Conclusion</h3>\n<p>This is a high-level overview of Universal Javascript SPAs. Check out <a href=\"/universal-javascript-app\">my React/Redux SPA boilerplate</a> to see a working example that I created and <a href=\"/vroom\">used in production at my last job</a>.</p>\n<p>As it gets easier and easier to make SPAs, they will become the norm because they offer a superior user experience. Props to all the open source developers who’ve made it fairly reasonable to set up. It’ll be exciting to see where things go in the future.</p>","frontmatter":{"title":"How to make a Universal Javascript Single-Page App with Server-Side Rendering","date":"August 20, 2019","cover":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/universal-javascript-app/"}}}